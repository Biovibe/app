<div class="mystress-content">
    <!-- Tab Navigation -->
    <div class="tab-navigation">
        <button class="tab-btn active" data-tab="live" id="tab-live">Live Session</button>
        <button class="tab-btn" data-tab="saved" id="tab-saved">Saved Sessions</button>
    </div>

    <!-- Live Session Tab -->
    <div class="tab-content active" id="live-tab">
        <!-- Stress Level Chart -->
        <div class="chart-container">
            <div class="chart-header">
                <h3>Stress Level Monitoring</h3>
                <div class="chart-controls">
                    <label for="csv-file-input" class="control-btn upload-btn" style="cursor: pointer; display: flex; align-items: center; gap: 6px;">
                        <span class="btn-icon">üìÅ</span>
                        <span class="btn-text">Upload</span>
                        <input type="file" id="csv-file-input" accept=".csv" style="display: none;" />
                    </label>
                    <button class="control-btn pause-btn" id="pause-resume-btn">
                        <span class="btn-icon">‚è∏Ô∏è</span>
                        <span class="btn-text">Pause</span>
                    </button>
                    <button class="control-btn save-btn" id="save-session-btn">
                        <span class="btn-icon">üíæ</span>
                        <span class="btn-text">Save Session</span>
                    </button>
                    <div id="connection-status" class="status disconnected" style="display: none;">Not Available</div>
                </div>
            </div>
            <div id="stress-chart" class="stress-chart"></div>
            <div class="chart-info">
                <div class="current-reading">
                    <span class="label">Stress Level:</span>
                    <span id="current-stress-level" class="value">--</span>
                </div>
                <div class="session-stats">
                    <div class="stat">
                        <span class="stat-label">Duration:</span>
                        <span id="session-duration" class="stat-value">00:00</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Saved Sessions Tab -->
    <div class="tab-content" id="saved-tab">
        <div class="saved-sessions-container">
            <div class="saved-sessions-header">
                <h3>Your Saved Sessions</h3>
                <button class="control-btn clear-all-btn" id="clear-all-sessions">
                    <span class="btn-icon">üóëÔ∏è</span>
                    <span class="btn-text">Clear All</span>
                </button>
            </div>
            <div id="saved-sessions-list" class="saved-sessions-list">
                <!-- Sessions will be populated here -->
            </div>
            <div class="session-detail-view" id="session-detail-view" style="display: none;">
                <div class="session-detail-content">
                    <div class="session-detail-header">
                        <h3 id="session-detail-title">Session Details</h3>
                        <button class="close-detail-btn" id="close-detail-btn">‚úï</button>
                    </div>
                    <div class="session-detail-stats">
                        <div class="detail-stat">
                            <span class="detail-label">Date:</span>
                            <span id="detail-date" class="detail-value">--</span>
                        </div>
                        <div class="detail-stat">
                            <span class="detail-label">Duration:</span>
                            <span id="detail-duration" class="detail-value">--</span>
                        </div>
                    </div>
                    <div id="saved-session-chart" class="stress-chart"></div>
                    <div id="high-stress-ranges" class="high-stress-ranges"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
.mystress-content * {
    box-sizing: border-box;
}

.mystress-content {
    padding: 15px 15px 30px 15px;
    background: var(--light-lavender);
    flex: 1 1 0;
    overflow-y: auto;
    overflow-x: hidden;
    max-width: 100%;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    gap: 15px;
    min-height: 0;
    -webkit-overflow-scrolling: touch;
}

/* Tab Navigation Styles */
.tab-navigation {
    display: flex;
    justify-content: center;
    gap: 10px;
    flex-shrink: 0;
    margin-bottom: 10px;
}

.tab-btn {
    padding: 10px 30px;
    border: none;
    background: var(--white);
    color: var(--dark-grey);
    border-radius: 25px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 1rem;
    font-weight: 500;
}

.tab-btn.active {
    background: var(--purple);
    color: var(--white);
    box-shadow: 0 4px 10px rgba(139, 92, 246, 0.3);
}

.tab-btn:hover:not(.active) {
    background: var(--greyish-purple);
}

/* Tab Content Styles */
.tab-content {
    display: none;
    flex-direction: column;
    gap: 15px;
    flex: 1;
    min-height: 0;
}

.tab-content.active {
    display: flex;
}

/* Chart Container Styles */
.chart-container.stress-high {
    background: #fff9c4;
    transition: background 0.3s ease;
}

.chart-container.stress-high .current-reading .label,
.chart-container.stress-high .current-reading .value {
    color: #c62828;
    text-transform: uppercase;
}

.chart-container {
    background: var(--white);
    border-radius: 15px;
    margin: 15px 0 30px 0;
    padding: 20px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    border: 1px solid var(--greyish-purple);
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 450px;
    height: auto;
    overflow: hidden;
}

.chart-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 15px;
    border-bottom: 2px solid var(--light-grey);
}

.chart-controls {
    display: flex;
    align-items: center;
    gap: 15px;
}

.chart-header h3 {
    margin: 0;
    color: var(--black);
    font-size: 1.4rem;
}

.control-btn {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 8px 12px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 0.9rem;
    transition: all 0.3s ease;
    font-weight: 500;
}

.pause-btn {
    background: var(--purple);
    color: var(--white);
}

.pause-btn:hover {
    background: var(--dark-purple);
}

.pause-btn.paused {
    background: #4CAF50;
}

.pause-btn.paused:hover {
    background: #45a049;
}

.save-btn {
    background: #4CAF50;
    color: var(--white);
}

.save-btn:hover {
    background: #45a049;
}

.save-btn:disabled {
    background: var(--light-grey);
    color: var(--dark-grey);
    cursor: not-allowed;
}

.upload-btn {
    background: #2196F3;
    color: var(--white);
}

.upload-btn:hover {
    background: #1976D2;
}

.clear-all-btn {
    background: #f44336;
    color: var(--white);
}

.clear-all-btn:hover {
    background: #d32f2f;
}

.btn-icon {
    font-size: 1rem;
}

.btn-text {
    font-size: 0.85rem;
}

.status {
    padding: 5px 12px;
    border-radius: 20px;
    font-size: 0.8rem;
    font-weight: bold;
    text-transform: uppercase;
}

.status.connected {
    background: #e8f5e8;
    color: #4CAF50;
}

.status.disconnected {
    background: #ffeaea;
    color: #f44336;
}

.stress-chart {
    width: 100%;
    flex: 1;
    min-height: 300px;
    margin: 0;
    overflow: hidden;
    position: relative;
}

.chart-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 5px;
    padding-top: 8px;
    border-top: 1px solid var(--light-grey);
    flex-shrink: 0;
}

.current-reading {
    display: flex;
    align-items: center;
    gap: 10px;
}

.current-reading .label {
    color: var(--dark-grey);
    font-weight: bold;
}

.current-reading .value {
    font-size: 1.5rem;
    font-weight: bold;
    color: var(--purple);
    padding: 5px 15px;
    background: var(--light-lavender);
    border-radius: 8px;
}

.session-stats {
    display: flex;
    gap: 20px;
}

.stat {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
}

.stat-label {
    font-size: 0.8rem;
    color: var(--dark-grey);
    margin-bottom: 5px;
}

.stat-value {
    font-size: 1.1rem;
    font-weight: bold;
    color: var(--black);
}

/* Saved Sessions Styles */
.saved-sessions-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 15px;
    min-height: 0;
}

.saved-sessions-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px;
    background: var(--white);
    border-radius: 15px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.saved-sessions-header h3 {
    margin: 0;
    color: var(--black);
    font-size: 1.4rem;
}

.saved-sessions-list {
    flex: 1;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 15px;
    overflow-y: auto;
    padding: 5px;
}

.session-card {
    background: var(--white);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    transition: all 0.3s ease;
    cursor: pointer;
    position: relative;
    border: 2px solid transparent;
}

.session-card:hover {
    box-shadow: 0 4px 16px rgba(139, 92, 246, 0.3);
    border-color: var(--purple);
    transform: translateY(-2px);
}

.session-card-header {
    display: flex;
    justify-content: space-between;
    align-items: start;
    margin-bottom: 10px;
}

.session-card-title {
    font-size: 1.1rem;
    font-weight: bold;
    color: var(--black);
    margin: 0;
}

.session-card-date {
    font-size: 0.85rem;
    color: var(--dark-grey);
    margin-top: 5px;
}

.session-card-delete {
    background: #f44336;
    color: white;
    border: none;
    border-radius: 50%;
    width: 24px;
    height: 24px;
    font-size: 0.9rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    z-index: 10;
}

.session-card-delete:hover {
    background: #d32f2f;
    transform: scale(1.1);
}

.session-card-stats {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    margin-top: 10px;
}

.session-card-stat {
    display: flex;
    flex-direction: column;
    gap: 3px;
}

.session-card-stat-label {
    font-size: 0.75rem;
    color: var(--dark-grey);
    text-transform: uppercase;
}

.session-card-stat-value {
    font-size: 1rem;
    font-weight: bold;
    color: var(--purple);
}

.empty-sessions {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 60px 20px;
    text-align: center;
    color: var(--dark-grey);
    background: var(--white);
    border-radius: 15px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.empty-sessions-icon {
    font-size: 4rem;
    margin-bottom: 20px;
    opacity: 0.5;
}

.empty-sessions-text {
    font-size: 1.2rem;
    font-weight: 500;
    margin-bottom: 10px;
}

.empty-sessions-subtext {
    font-size: 0.9rem;
    opacity: 0.7;
}

/* Session Detail View */
.session-detail-view {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.6);
    z-index: 2000;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    backdrop-filter: blur(3px);
}

.session-detail-content {
    background: var(--white);
    border-radius: 15px;
    padding: 25px;
    max-width: 900px;
    width: 100%;
    max-height: 90vh;
    overflow-y: auto;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    animation: modalFadeIn 0.3s ease;
}

@keyframes modalFadeIn {
    from {
        opacity: 0;
        transform: scale(0.95) translateY(-20px);
    }
    to {
        opacity: 1;
        transform: scale(1) translateY(0);
    }
}

.session-detail-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 15px;
    border-bottom: 2px solid var(--light-grey);
}

.session-detail-header h3 {
    margin: 0;
    color: var(--black);
    font-size: 1.4rem;
}

.close-detail-btn {
    background: var(--light-grey);
    border: none;
    border-radius: 50%;
    width: 32px;
    height: 32px;
    font-size: 1.2rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    color: var(--dark-grey);
}

.close-detail-btn:hover {
    background: var(--greyish-purple);
    color: var(--purple);
    transform: rotate(90deg);
}

.session-detail-stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 15px;
    margin-bottom: 20px;
}

.detail-stat {
    background: var(--light-lavender);
    padding: 12px;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.detail-label {
    font-size: 0.8rem;
    color: var(--dark-grey);
    text-transform: uppercase;
    font-weight: 500;
}

.detail-value {
    font-size: 1.2rem;
    font-weight: bold;
    color: var(--purple);
}

.high-stress-ranges {
    margin-top: 15px;
    padding: 12px;
    background: #fff8e1;
    border-radius: 8px;
    border-left: 4px solid #c62828;
}

.high-stress-ranges-title {
    font-size: 0.9rem;
    font-weight: bold;
    color: var(--dark-grey);
    margin-bottom: 8px;
}

.high-stress-ranges-list {
    font-size: 0.9rem;
    color: var(--black);
}

.high-stress-range-item {
    display: flex;
    align-items: center;
    gap: 16px;
    padding: 8px 0;
    border-bottom: 1px solid rgba(0, 0, 0, 0.15);
    flex-wrap: wrap;
}

.high-stress-range-item:last-child {
    border-bottom: none;
}

.high-stress-range-time {
    font-weight: 500;
    min-width: 140px;
}

.high-stress-range-label {
    font-size: 0.85rem;
    color: var(--dark-grey);
    font-style: italic;
    margin-bottom: 4px;
    width: 100%;
}

.high-stress-range-faces {
    flex: 1;
    display: flex;
    justify-content: center;
    gap: 4px;
}

.high-stress-range-category {
    margin-left: auto;
}

.high-stress-range-faces button {
    padding: 4px 8px;
    border: 2px solid transparent;
    border-radius: 8px;
    font-size: 1.3rem;
    background: transparent;
    cursor: pointer;
    transition: all 0.2s ease;
}

.high-stress-range-faces button:hover {
    background: rgba(139, 92, 246, 0.15);
}

.high-stress-range-faces button.selected {
    border-color: var(--purple);
    background: rgba(139, 92, 246, 0.2);
}

.stress-category-select {
    padding: 6px 10px;
    border-radius: 6px;
    border: 1px solid var(--greyish-purple);
    font-size: 0.85rem;
    background: var(--white);
}

/* Responsive design */
@media (max-width: 768px) {
    .mystress-content {
        padding: 10px;
        gap: 10px;
    }
    
    .chart-container {
        padding: 15px;
        margin: 0;
        min-height: 400px;
    }
    
    .chart-header {
        flex-direction: column;
        gap: 10px;
        align-items: flex-start;
        margin-bottom: 10px;
        padding-bottom: 10px;
    }
    
    .chart-header h3 {
        font-size: 1.2rem;
    }
    
    .chart-controls {
        gap: 10px;
        align-self: stretch;
        justify-content: space-between;
    }
    
    .control-btn {
        padding: 6px 10px;
        font-size: 0.8rem;
    }
    
    .stress-chart {
        min-height: 250px;
        max-height: 300px;
        margin: 10px 0;
        overflow: hidden;
        touch-action: pan-x pan-y;
    }
    
    .chart-info {
        flex-direction: column;
        gap: 15px;
        align-items: flex-start;
        margin-top: 10px;
        padding-top: 10px;
    }
    
    .session-stats {
        gap: 15px;
        width: 100%;
        justify-content: space-around;
    }
    
    .current-reading .value {
        font-size: 1.3rem;
    }
    
    /* Tab styles for mobile */
    .tab-navigation {
        gap: 5px;
        margin-bottom: 5px;
    }
    
    .tab-btn {
        padding: 8px 20px;
        font-size: 0.9rem;
    }
    
    /* Saved sessions for mobile */
    .saved-sessions-list {
        grid-template-columns: 1fr;
    }
    
    .saved-sessions-header {
        padding: 12px;
        flex-direction: column;
        gap: 10px;
        align-items: flex-start;
    }
    
    .saved-sessions-header h3 {
        font-size: 1.2rem;
    }
    
    .session-card-stats {
        grid-template-columns: 1fr 1fr;
    }
    
    .session-detail-content {
        padding: 15px;
        max-height: 85vh;
    }
    
    .session-detail-header h3 {
        font-size: 1.2rem;
    }
    
    .session-detail-stats {
        grid-template-columns: 1fr 1fr;
    }
    
    #saved-session-chart {
        min-height: 250px;
        max-height: 300px;
        overflow: hidden;
    }
}
</style>

<script>
// Add Plotly.js library
const plotlyScript = document.createElement('script');
plotlyScript.src = 'https://cdn.plot.ly/plotly-latest.min.js';
document.head.appendChild(plotlyScript);

// Global variables
// Chart variables
let stressTimeData = [];
let stressValueData = [];
let sessionStartTime = Date.now();
let sessionStats = {
    average: 0,
    peak: 0,
    current: 0,
    count: 0,
    sum: 0
};

// Pause state
let isPaused = false;

// Saved sessions storage
let savedSessions = [];
let currentTab = 'live';

// Streaming state for incremental plotting
let streamingInterval = null;
let streamingData = {
    timeSeconds: [],
    stressValues: [],
    processedBands: {},
    currentIndex: 0
};

// Initialize the page
document.addEventListener('DOMContentLoaded', function() {
    loadSavedSessions();
    initializeEventListeners();
    initializeTabListeners();
    initializePauseButton();
    initializeSaveButton();
    initializeStressChart();
    initializeCSVUpload();
    renderSavedSessions();
});

// Initialize all event listeners
function initializeEventListeners() {
    // No date navigation - always showing today only
}

// Initialize tab listeners
function initializeTabListeners() {
    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            switchTab(this.dataset.tab);
        });
    });
    
    // Close detail view button
    document.getElementById('close-detail-btn').addEventListener('click', function() {
        closeSessionDetail();
    });
    
    // Clear all sessions button
    document.getElementById('clear-all-sessions').addEventListener('click', function() {
        if (confirm('Are you sure you want to delete all saved sessions? This action cannot be undone.')) {
            clearAllSessions();
        }
    });
    
    // Close detail view when clicking outside
    document.getElementById('session-detail-view').addEventListener('click', function(e) {
        if (e.target === this) {
            closeSessionDetail();
        }
    });
}

// Switch between tabs
function switchTab(tabName) {
    currentTab = tabName;
    
    // Update active tab button
    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    document.getElementById('tab-' + tabName).classList.add('active');
    
    // Show appropriate content
    document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
    });
    document.getElementById(tabName + '-tab').classList.add('active');
    
    // Refresh saved sessions list when switching to saved tab
    if (tabName === 'saved') {
        renderSavedSessions();
    }
}

// Initialize stress monitoring chart
function initializeStressChart() {
    plotlyScript.onload = function() {
        const plotData = [{
            x: stressTimeData,
            y: stressValueData,
            type: 'scatter',
            mode: 'lines+markers',
            line: {color: '#8B5CF6', width: 3},
            marker: {size: 6, color: '#8B5CF6'},
            name: 'Stress Level',
            fill: 'tonexty',
            fillcolor: 'rgba(139, 92, 246, 0.1)'
        }];

        const layout = {
            title: {
                text: 'Stress Level Monitoring',
                font: {size: 16, color: '#333'}
            },
            xaxis: {
                title: 'Time (seconds)',
                gridcolor: '#f0f0f0',
                showgrid: true,
                tickformat: 'd',
                dtick: 1
            },
            yaxis: {
                title: 'Stress Level',
                autorange: true,
                gridcolor: '#f0f0f0',
                showgrid: true,
                dtick: 1
            },
            showlegend: false,
            margin: {l: 60, r: 30, t: 50, b: 70},
            plot_bgcolor: 'white',
            paper_bgcolor: 'white'
        };

        Plotly.newPlot('stress-chart', plotData, layout, {
            responsive: true,
            displayModeBar: false,
            staticPlot: false,
            scrollZoom: false
        });
    };
}

// CSV parsing functions (matching SSEServer.py logic)
function parseRow(line) {
    // CSV line: timestamp, v1, v2, ...
    // Skip empty lines or lines starting with "File created"
    line = line.trim();
    if (!line || line.startsWith("File created")) {
        return null;
    }
    
    const parts = line.split(',');
    if (parts.length < 2) return null;
    
    const ts = parts[0].trim();
    const values = parts.slice(1).map(v => {
        const trimmed = v.trim();
        if (!trimmed) return null;
        const num = parseFloat(trimmed);
        return isNaN(num) ? null : num;
    });
    
    // Check if we have a valid timestamp and at least one valid numeric value
    if (!ts || !values.some(v => v !== null && !isNaN(v))) return null;
    
    return { timestamp: ts, values };
}

function parseTimestampToMs(tsStr) {
    // Normalize "YYYY-MM-DD HH:MM:SS.mmmuuu" -> "YYYY-MM-DDTHH:MM:SS.mmm"
    const normalized = tsStr.replace(' ', 'T').replace(/\.(\d{3})\d+$/, '.$1');
    const parsed = Date.parse(normalized);
    return isNaN(parsed) ? null : parsed;
}

function elapsedSeconds(timestampsMs) {
    if (!timestampsMs || !Array.isArray(timestampsMs) || !timestampsMs.length) return [];
    const t0 = timestampsMs[0];
    return timestampsMs.map(t => (t - t0) / 1000);
}

// Precomputed SciPy butter(4, band, fs=256, output='sos') coefficients (from plot_csv_sse_v2.html)
// Each row: [b0, b1, b2, a0, a1, a2]
const SOS_MAP = {
    delta: [
        [3.049431e-06, 6.098862e-06, 3.049431e-06, 1.0, -1.870149771975, 0.875842589569],
        [1.0, 2.0, 1.0, 1.0, -1.934664050576, 0.943586791437],
        [1.0, -2.0, 1.0, 1.0, -1.97380955467, 0.974045607595],
        [1.0, -2.0, 1.0, 1.0, -1.992248504568, 0.992405879962],
    ],
    alpha: [
        [1.2134333e-05, 2.4268666e-05, 1.2134333e-05, 1.0, -1.812006276821, 0.883140501637],
        [1.0, 2.0, 1.0, 1.0, -1.853236722842, 0.902229612842],
        [1.0, -2.0, 1.0, 1.0, -1.849664736864, 0.944535265517],
        [1.0, -2.0, 1.0, 1.0, -1.924909923565, 0.963969676428],
    ],
    beta: [
        [0.001159024932, 0.002318049864, 0.001159024932, 1.0, -1.360825895842, 0.631413287771],
        [1.0, 2.0, 1.0, 1.0, -1.580273251141, 0.720901252756],
        [1.0, -2.0, 1.0, 1.0, -1.362661520584, 0.810386425508],
        [1.0, -2.0, 1.0, 1.0, -1.801507804674, 0.902634931661],
    ],
};

// Configuration matching plot_csv_sse_v2.html
const FS = 256; // Hz
const BANDS = {
    delta: { low: 0.5, high: 4, color: '#1565c0' },
    alpha: { low: 8, high: 13, color: '#2e7d32' },
    beta:  { low: 13, high: 30, color: '#c62828' },
};

function filtfilt(data, sos) {
    // Forward-backward filtering using IIRFilter + biquad cascade (from plot_csv_sse_v2.html)
    const forward = applySOS(data, sos);
    const reversed = forward.slice().reverse();
    const backward = applySOS(reversed, sos);
    return backward.reverse();
}

function applySOS(data, sos) {
    // sos: array of [b0,b1,b2,a0,a1,a2] (from plot_csv_sse_v2.html)
    let y = data.slice();
    sos.forEach(([b0,b1,b2,a0,a1,a2]) => {
        // Direct Form II Transposed
        let z1 = 0, z2 = 0;
        const out = new Array(y.length);
        for (let i = 0; i < y.length; i++) {
            const x = y[i];
            const y0 = b0*x + z1;
            z1 = b1*x - a1*y0 + z2;
            z2 = b2*x - a2*y0;
            out[i] = y0;
        }
        y = out;
    });
    return y;
}

function zscore(arr) {
    // Z-score normalization (from plot_csv_sse_v2.html)
    const n = arr.length;
    if (!n) return [];
    const mean = arr.reduce((s, v) => s + v, 0) / n;
    const std = Math.sqrt(arr.reduce((s, v) => s + (v - mean) * (v - mean), 0) / n) || 1;
    return arr.map(v => (v - mean) / std);
}

// Initialize CSV file upload
function initializeCSVUpload() {
    const fileInput = document.getElementById('csv-file-input');
    if (!fileInput) return;
    
    fileInput.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(event) {
            try {
                const text = event.target.result;
                const lines = text.split(/\r?\n/).filter(Boolean);
                const rows = [];
                
                // Parse CSV rows using same logic as SSEServer.py
                for (const line of lines) {
                    const parsed = parseRow(line);
                    if (parsed) {
                        rows.push(parsed);
                    }
                }
                
                if (rows.length === 0) {
                    alert('No valid data found in CSV file. Please check the file format.');
                    return;
                }
                
                // Process CSV data and update chart
                processCSVData(rows);
                
                console.log(`Loaded ${rows.length} rows from CSV file`);
            } catch (error) {
                console.error('Error reading CSV file:', error);
                alert('Error reading CSV file: ' + error.message);
            }
        };
        
        reader.onerror = function() {
            alert('Error reading file');
        };
        
        reader.readAsText(file);
    });
}

// Process CSV data and update stress chart with simulated-live streaming
function processCSVData(rows) {
    // Reset session data
    resetStressSession();
    
    // Stop any existing streaming
    if (streamingInterval) {
        clearInterval(streamingInterval);
        streamingInterval = null;
    }
    
    if (rows.length === 0) {
        alert('No valid data found in CSV file.');
        return;
    }
    
    try {
        // Validate rows structure
        if (!rows || !Array.isArray(rows) || rows.length === 0) {
            alert('Invalid CSV data format.');
            return;
        }
        
        // Filter rows to only include those with valid structure
        const validRows = rows.filter(r => 
            r && 
            r.values && 
            Array.isArray(r.values) && 
            r.values.length > 0 &&
            r.timestamp
        );
        
        if (validRows.length === 0) {
            alert('No valid rows found in CSV file.');
            return;
        }
        
        // Extract stress values from CSV using the same filtered rows
        // Using first value column (index 0) - adjust if needed for your data format
        const stressValues = validRows
            .map(r => r.values[0])
            .filter(v => v !== null && v !== undefined && !isNaN(v));
        
        if (stressValues.length === 0) {
            alert('No valid numeric values found in CSV file.');
            return;
        }
        
        // Parse timestamps using the same filtered rows (keep same length)
        const tsMsRaw = validRows.map(r => parseTimestampToMs(r.timestamp));
        const tsMs = tsMsRaw.filter(t => t !== null && t !== undefined);
        
        let timeSeconds;
        if (tsMs.length === stressValues.length && tsMs.length > 0 && Array.isArray(tsMs)) {
            // Use actual timestamps
            timeSeconds = elapsedSeconds(tsMs);
        } else {
            // Fallback: use index-based time (matching plot_csv_sse_v2.html: fs=256 Hz)
            timeSeconds = [...Array(stressValues.length).keys()].map(i => i / FS);
        }
        
        // Ensure arrays have same length
        if (stressValues.length !== timeSeconds.length) {
            // Trim to shortest array
            const minLength = Math.min(stressValues.length, timeSeconds.length);
            stressValues.splice(minLength);
            timeSeconds.splice(minLength);
        }
        
        // Validate arrays before proceeding
        if (!stressValues.length || !timeSeconds.length) {
            alert('Could not process CSV data - invalid array lengths.');
            return;
        }
        
        // Pre-process all data for streaming (matching plot_csv_sse_v2.html approach exactly)
        const N = stressValues.length;
        const sig = stressValues; // Signal data (column 1 per requirement, matching plot_csv_sse_v2.html)
        const tSec = timeSeconds; // Time in seconds
        
        // Pre-process all filtered signals (matching plot_csv_sse_v2.html exactly)
        const processedBands = {};
        Object.entries(BANDS).forEach(([name, cfg]) => {
            const sos = SOS_MAP[name];
            if (!sos) throw new Error(`No SOS for band ${name}`);
            const filtered = filtfilt(sig, sos);
            const normed = zscore(filtered);
            processedBands[name] = normed;
        });
        
        // Calculate the full x-axis range based on file size
        const minT = 0;
        const maxT = tSec.length > 0 ? tSec[tSec.length - 1] : 1;
        
        // Calculate the full y-axis range from all processed bands (matching plot_csv_sse_v2.html)
        const allYValues = [
            ...processedBands.delta,
            ...processedBands.alpha,
            ...processedBands.beta
        ];
        const minY = Math.min(...allYValues);
        const maxY = Math.max(...allYValues);
        const yPadding = (maxY - minY) * 0.1; // 10% padding
        const yMin = minY - yPadding;
        const yMax = maxY + yPadding;
        
        // Initialize plot with empty traces (matching plot_csv_sse_v2.html - one trace per band)
        const traces = [];
        Object.entries(BANDS).forEach(([name, cfg]) => {
            traces.push({
                x: [],
                y: [],
                type: 'scatter',
                mode: 'lines',
                name: name,
                line: { width: 1.5, color: cfg.color },
            });
        });

        const layout = {
            title: {
                text: 'Stress Level Monitoring',
                font: {size: 16, color: '#333'}
            },
            xaxis: {
                title: 'Time (seconds)',
                gridcolor: '#f0f0f0',
                showgrid: true,
                range: [minT, maxT]  // Fixed range to full file size
            },
            yaxis: {
                title: 'Z-score',
                gridcolor: '#f0f0f0',
                showgrid: true,
                range: [yMin, yMax]  // Fixed range based on all data
            },
            showlegend: true,
            legend: { x: 1, y: 1, xanchor: 'right', yanchor: 'bottom', orientation: 'v' },
            margin: {l: 60, r: 100, t: 50, b: 70},
            plot_bgcolor: 'white',
            paper_bgcolor: 'white'
        };

        if (typeof Plotly !== 'undefined' && document.getElementById('stress-chart')) {
            Plotly.newPlot('stress-chart', traces, layout, {
                responsive: true,
                displayModeBar: false,
                staticPlot: false,
                scrollZoom: false
            });
        }
        
        // Store pre-processed band data for streaming
        streamingData.timeSeconds = tSec;
        streamingData.processedBands = processedBands;
        streamingData.currentIndex = 0;
        
        // Start incremental streaming matching plot_csv_sse_v2.html timing (50ms per point = 20 points/second)
        startIncrementalStreaming(processedBands, tSec);
        
    } catch (error) {
        console.error('Error processing CSV data:', error);
        alert('Error processing CSV data: ' + error.message);
    }
}

// Start incremental streaming of data points (matching plot_csv_sse_v2.html logic exactly)
function startIncrementalStreaming(processedBands, timeSeconds) {
    const N = processedBands.delta.length; // All bands have same length
    let currentIndex = 0;
    
    // Calculate stats from delta band (or combine all bands)
    const allValues = [
        ...processedBands.delta,
        ...processedBands.alpha,
        ...processedBands.beta
    ];
    
    // Update stats as we stream (will be finalized at end)
    sessionStats.count = N;
    sessionStats.sum = processedBands.delta.reduce((a, b) => a + b, 0);
    sessionStats.average = sessionStats.sum / sessionStats.count;
    sessionStats.peak = Math.max(...processedBands.delta);
    
    // Calculate duration from x-axis time range (matches the timeSeconds array)
    const totalDurationSeconds = timeSeconds.length > 0 ? timeSeconds[timeSeconds.length - 1] : 0;
    sessionStartTime = Date.now() - (totalDurationSeconds * 1000);
    
    // Stream points one at a time at 70 points per second (14ms per point)
    streamingInterval = setInterval(() => {
        if (currentIndex >= N) {
            // Streaming complete
            clearInterval(streamingInterval);
            streamingInterval = null;
            
            // Finalize data arrays (store delta band for stress level display)
            stressTimeData = [...timeSeconds];
            stressValueData = [...processedBands.delta];
            
            // Update final statistics
            updateStressStats();
            updateSaveButtonState();
            
            // Update session duration to match x-axis time range
            const durationSeconds = Math.floor(totalDurationSeconds);
            const minutes = Math.floor(durationSeconds / 60);
            const seconds = durationSeconds % 60;
            document.getElementById('session-duration').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            console.log(`Finished streaming ${N} data points`);
            return;
        }
        
        // Skip if paused
        if (isPaused) {
            return;
        }
        
        // Extend each trace with the next point (matching plot_csv_sse_v2.html extendTraces pattern exactly)
        if (typeof Plotly !== 'undefined' && document.getElementById('stress-chart')) {
            const xValues = [
                [timeSeconds[currentIndex]], 
                [timeSeconds[currentIndex]], 
                [timeSeconds[currentIndex]]
            ];
            const yValues = [
                [processedBands.delta[currentIndex]],
                [processedBands.alpha[currentIndex]],
                [processedBands.beta[currentIndex]]
            ];
            
            Plotly.extendTraces('stress-chart', {
                x: xValues,
                y: yValues
            }, [0, 1, 2]); // Update all three traces
            
            // Keep x-axis fixed to full file range (no sliding window) - matching plot_csv_sse_v2.html
        }
        
        // Update current stress level as we stream (using delta band)
        sessionStats.current = processedBands.delta[currentIndex];
        updateStressLevelDisplay(sessionStats.current);
        
        currentIndex++;
        streamingData.currentIndex = currentIndex;
    }, 25); 
}


// Format stress level display: Low (< 0.3), Moderate (0.3‚Äì0.7), High (> 0.7)
function formatStressLevel(value) {
    if (value === null || value === undefined || isNaN(value)) {
        return '--';
    }
    if (value < 0.3) return 'Low';
    if (value <= 0.7) return 'Moderate';
    return 'High';
}

// Update stress level display; yellow background and red caps label while High
function updateStressLevelDisplay(value) {
    const displayValue = formatStressLevel(value);
    const chartContainer = document.querySelector('.chart-container');
    
    if (chartContainer) {
        if (displayValue === 'High') {
            chartContainer.classList.add('stress-high');
        } else {
            chartContainer.classList.remove('stress-high');
        }
    }
    
    document.getElementById('current-stress-level').textContent = displayValue;
}

// Update stress statistics display
function updateStressStats() {
    updateStressLevelDisplay(sessionStats.current);
}

// Update session duration
function updateSessionDuration() {
    // Only update duration if not paused
    if (!isPaused) {
        const duration = Math.floor((Date.now() - sessionStartTime) / 1000);
        const minutes = Math.floor(duration / 60);
        const seconds = duration % 60;
        
        document.getElementById('session-duration').textContent = 
            `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }
}

// Reset session data when period changes
function resetStressSession() {
    // Stop any active streaming
    if (streamingInterval) {
        clearInterval(streamingInterval);
        streamingInterval = null;
    }
    
    stressTimeData = [];
    stressValueData = [];
    sessionStartTime = Date.now();
    sessionStats = {
        average: 0,
        peak: 0,
        current: 0,
        count: 0,
        sum: 0
    };
    
    streamingData = {
        timeSeconds: [],
        stressValues: [],
        processedBands: {},
        currentIndex: 0
    };
    
    // Clear the chart
    if (typeof Plotly !== 'undefined' && document.getElementById('stress-chart')) {
        Plotly.update('stress-chart', {
            x: [[]],
            y: [[]]
        });
    }
    
    // Reset stats display
    document.querySelector('.chart-container')?.classList.remove('stress-high');
    document.getElementById('current-stress-level').textContent = '--';
    document.getElementById('session-duration').textContent = '00:00';
    
    // Reset pause state
    isPaused = false;
    updatePauseButton();
}

// Initialize pause button
function initializePauseButton() {
    const pauseBtn = document.getElementById('pause-resume-btn');
    pauseBtn.addEventListener('click', togglePause);
    updatePauseButton();
}

// Toggle pause/resume state
function togglePause() {
    isPaused = !isPaused;
    updatePauseButton();
    
    if (isPaused) {
        console.log('Data streaming paused');
        // Update chart title to show paused state
        if (typeof Plotly !== 'undefined' && document.getElementById('stress-chart')) {
            Plotly.relayout('stress-chart', {
                'title.text': 'Stress Level Monitoring (PAUSED)'
            });
        }
    } else {
        console.log('Data streaming resumed');
        // Update chart title to show resumed state
        if (typeof Plotly !== 'undefined' && document.getElementById('stress-chart')) {
            Plotly.relayout('stress-chart', {
                'title.text': 'Stress Level Monitoring'
            });
        }
    }
}

// Update pause button appearance and text
function updatePauseButton() {
    const pauseBtn = document.getElementById('pause-resume-btn');
    const btnIcon = pauseBtn.querySelector('.btn-icon');
    const btnText = pauseBtn.querySelector('.btn-text');
    
    if (isPaused) {
        pauseBtn.classList.add('paused');
        btnIcon.textContent = '‚ñ∂Ô∏è';
        btnText.textContent = 'Resume';
    } else {
        pauseBtn.classList.remove('paused');
        btnIcon.textContent = '‚è∏Ô∏è';
        btnText.textContent = 'Pause';
    }
}

// Initialize save button
function initializeSaveButton() {
    const saveBtn = document.getElementById('save-session-btn');
    saveBtn.addEventListener('click', saveCurrentSession);
    updateSaveButtonState();
}

// Update save button state
function updateSaveButtonState() {
    const saveBtn = document.getElementById('save-session-btn');
    if (stressTimeData.length === 0) {
        saveBtn.disabled = true;
    } else {
        saveBtn.disabled = false;
    }
}

// Save current session
function saveCurrentSession() {
    if (stressTimeData.length === 0) {
        alert('No data to save. Start monitoring to record a session.');
        return;
    }
    
    const session = {
        id: Date.now(),
        date: new Date().toISOString(),
        dateFormatted: new Date().toLocaleString('en-US', { 
            weekday: 'long', 
            year: 'numeric', 
            month: 'long', 
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        }),
        duration: Math.floor((Date.now() - sessionStartTime) / 1000),
        timeData: [...stressTimeData],
        valueData: [...stressValueData],
        stats: {
            average: sessionStats.average,
            peak: sessionStats.peak,
            count: sessionStats.count
        }
    };
    
    savedSessions.unshift(session); // Add to beginning of array
    saveSessions();
    
    // Show success message
    alert('Session saved successfully!');
    
    // Switch to saved sessions tab
    switchTab('saved');
}

// Load saved sessions from localStorage
function loadSavedSessions() {
    try {
        const stored = localStorage.getItem('stressSessions');
        if (stored) {
            savedSessions = JSON.parse(stored);
        }
    } catch (error) {
        console.error('Error loading saved sessions:', error);
        savedSessions = [];
    }
}

// Save sessions to localStorage
function saveSessions() {
    try {
        localStorage.setItem('stressSessions', JSON.stringify(savedSessions));
    } catch (error) {
        console.error('Error saving sessions:', error);
        alert('Failed to save session. Storage may be full.');
    }
}

// Render saved sessions list
function renderSavedSessions() {
    const listContainer = document.getElementById('saved-sessions-list');
    
    if (savedSessions.length === 0) {
        listContainer.innerHTML = `
            <div class="empty-sessions">
                <div class="empty-sessions-icon">üìä</div>
                <div class="empty-sessions-text">No Saved Sessions</div>
                <div class="empty-sessions-subtext">Start a monitoring session and click "Save Session" to keep it for later review.</div>
            </div>
        `;
        return;
    }
    
    listContainer.innerHTML = '';
    savedSessions.forEach((session, index) => {
        const card = createSessionCard(session, index);
        listContainer.appendChild(card);
    });
}

// Create a session card element
function createSessionCard(session, index) {
    const card = document.createElement('div');
    card.className = 'session-card';
    
    const duration = formatDuration(session.duration);
    
    card.innerHTML = `
        <div class="session-card-header">
            <div>
                <div class="session-card-title">Session ${savedSessions.length - index}</div>
                <div class="session-card-date">${session.dateFormatted}</div>
            </div>
            <button class="session-card-delete" onclick="deleteSession(${session.id}); event.stopPropagation();">‚úï</button>
        </div>
        <div class="session-card-stats">
            <div class="session-card-stat">
                <div class="session-card-stat-label">Duration</div>
                <div class="session-card-stat-value">${duration}</div>
            </div>
            <div class="session-card-stat">
                <div class="session-card-stat-label">Data Points</div>
                <div class="session-card-stat-value">${session.stats.count}</div>
            </div>
        </div>
    `;
    
    card.addEventListener('click', function() {
        viewSessionDetail(session);
    });
    
    return card;
}

// Format duration in seconds to MM:SS
function formatDuration(seconds) {
    const minutes = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

// Delete a session
function deleteSession(sessionId) {
    if (confirm('Are you sure you want to delete this session?')) {
        savedSessions = savedSessions.filter(s => s.id !== sessionId);
        saveSessions();
        renderSavedSessions();
    }
}

// Clear all sessions
function clearAllSessions() {
    savedSessions = [];
    saveSessions();
    renderSavedSessions();
}

// View session detail
function viewSessionDetail(session) {
    const detailView = document.getElementById('session-detail-view');
    
    // Update stats
    document.getElementById('detail-date').textContent = session.dateFormatted;
    document.getElementById('detail-duration').textContent = formatDuration(session.duration);
    
    // Show the modal
    detailView.style.display = 'flex';
    
    // Create chart container if it doesn't exist properly
    const chartContainer = document.getElementById('saved-session-chart');
    
    // Wait for Plotly to be loaded
    if (typeof Plotly !== 'undefined') {
        renderSessionChart(session);
    } else {
        plotlyScript.onload = function() {
            renderSessionChart(session);
        };
    }
}

// Find contiguous time ranges where stress is High (value > 0.7)
function getHighStressRanges(timeData, valueData) {
    const ranges = [];
    const HIGH_THRESHOLD = 0.7;
    if (!timeData || !valueData || timeData.length !== valueData.length || timeData.length === 0) {
        return ranges;
    }
    let inRange = false;
    let startIdx = 0;
    for (let i = 0; i < valueData.length; i++) {
        const v = valueData[i];
        const isHigh = v !== null && v !== undefined && !isNaN(v) && v > HIGH_THRESHOLD;
        if (isHigh && !inRange) {
            inRange = true;
            startIdx = i;
        } else if (!isHigh && inRange) {
            inRange = false;
            ranges.push({
                start: timeData[startIdx],
                end: timeData[i - 1]
            });
        }
    }
    if (inRange) {
        ranges.push({
            start: timeData[startIdx],
            end: timeData[timeData.length - 1]
        });
    }
    return ranges;
}

// Render session chart
function renderSessionChart(session) {
    const plotData = [{
        x: session.timeData,
        y: session.valueData,
        type: 'scatter',
        mode: 'lines+markers',
        line: {color: '#8B5CF6', width: 3},
        marker: {size: 6, color: '#8B5CF6'},
        name: 'Stress Level',
        fill: 'tonexty',
        fillcolor: 'rgba(139, 92, 246, 0.1)'
    }];

    const layout = {
        title: {
            text: 'Session Data',
            font: {size: 16, color: '#333'}
        },
        xaxis: {
            title: 'Time (seconds)',
            gridcolor: '#f0f0f0',
            showgrid: true,
            nticks: 6
        },
        yaxis: {
            title: 'Stress Level',
            range: [-8, 8],
            gridcolor: '#f0f0f0',
            showgrid: true
        },
        showlegend: false,
        margin: {l: 60, r: 30, t: 50, b: 70},
        plot_bgcolor: 'white',
        paper_bgcolor: 'white'
    };

    Plotly.newPlot('saved-session-chart', plotData, layout, {
        responsive: true,
        displayModeBar: false,
        staticPlot: false,
        scrollZoom: false
    });

    // Show high-stress time ranges under the chart (date/time labels)
    const ranges = getHighStressRanges(session.timeData, session.valueData);
    const rangesEl = document.getElementById('high-stress-ranges');
    if (ranges.length === 0) {
        rangesEl.innerHTML = '<div class="high-stress-ranges-title">High stress periods</div><div class="high-stress-ranges-list">None</div>';
    } else {
        if (!session.stressRangeLabels) session.stressRangeLabels = [];
        const sessionStartMs = new Date(session.date).getTime() - (session.duration || 0) * 1000;
        const opts = { hour: 'numeric', minute: '2-digit', second: '2-digit', hour12: true };
        const listHtml = ranges.map((r, idx) => {
            const startMs = sessionStartMs + (typeof r.start === 'number' ? r.start : parseFloat(r.start)) * 1000;
            const endMs = sessionStartMs + (typeof r.end === 'number' ? r.end : parseFloat(r.end)) * 1000;
            const startStr = new Date(startMs).toLocaleTimeString('en-US', opts);
            const endStr = new Date(endMs).toLocaleTimeString('en-US', opts);
            const labels = session.stressRangeLabels[idx] || {};
            const typeVal = labels.type || '';
            const categoryVal = labels.category || '';
            const verySadSelected = typeVal === 'very sad';
            const sadSelected = typeVal === 'sad';
            const neutralSelected = typeVal === 'neutral';
            const happySelected = typeVal === 'happy';
            const veryHappySelected = typeVal === 'very happy';
            return `<div class="high-stress-range-item" data-session-id="${session.id}" data-range-index="${idx}">
                <div class="high-stress-range-time">${startStr} ‚Äì ${endStr}</div>
                <div class="high-stress-range-label">How were you feeling during this time?</div>
                <div class="high-stress-range-faces">
                    <button type="button" class="stress-face-btn" data-value="very sad" title="Very Sad"${verySadSelected ? ' data-selected' : ''}>üò¢</button>
                    <button type="button" class="stress-face-btn" data-value="sad" title="Sad"${sadSelected ? ' data-selected' : ''}>üôÅ</button>
                    <button type="button" class="stress-face-btn" data-value="neutral" title="Neutral"${neutralSelected ? ' data-selected' : ''}>üòê</button>
                    <button type="button" class="stress-face-btn" data-value="happy" title="Happy"${happySelected ? ' data-selected' : ''}>üôÇ</button>
                    <button type="button" class="stress-face-btn" data-value="very happy" title="Very Happy"${veryHappySelected ? ' data-selected' : ''}>üòÑ</button>
                </div>
                <div class="high-stress-range-category">
                    <select class="stress-category-select">
                        <option value="">Select category...</option>
                        <option value="homework"${categoryVal === 'homework' ? ' selected' : ''}>Homework</option>
                        <option value="exam"${categoryVal === 'exam' ? ' selected' : ''}>Exam/Test</option>
                        <option value="work"${categoryVal === 'work' ? ' selected' : ''}>Work</option>
                        <option value="social"${categoryVal === 'social' ? ' selected' : ''}>Social Interaction</option>
                        <option value="family"${categoryVal === 'family' ? ' selected' : ''}>Family</option>
                        <option value="relationship"${categoryVal === 'relationship' ? ' selected' : ''}>Relationship</option>
                        <option value="physical stress"${categoryVal === 'physical stress' ? ' selected' : ''}>Physical Stress</option>
                        <option value="exercise"${categoryVal === 'exercise' ? ' selected' : ''}>Exercise</option>
                        <option value="financial"${categoryVal === 'financial' ? ' selected' : ''}>Financial</option>
                        <option value="health"${categoryVal === 'health' ? ' selected' : ''}>Health</option>
                        <option value="deadline"${categoryVal === 'deadline' ? ' selected' : ''}>Deadline Pressure</option>
                        <option value="presentation"${categoryVal === 'presentation' ? ' selected' : ''}>Presentation/Speech</option>
                        <option value="travel"${categoryVal === 'travel' ? ' selected' : ''}>Travel</option>
                        <option value="sleep"${categoryVal === 'sleep' ? ' selected' : ''}>Sleep Deprivation</option>
                        <option value="other"${categoryVal === 'other' ? ' selected' : ''}>Other</option>
                    </select>
                </div>
            </div>`;
        }).join('');
        rangesEl.innerHTML = '<div class="high-stress-ranges-title">High stress periods</div><div class="high-stress-ranges-list">' + listHtml + '</div>';
        rangesEl.querySelectorAll('.stress-face-btn[data-selected]').forEach(btn => btn.classList.add('selected'));
        rangesEl.querySelectorAll('.stress-face-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                const item = this.closest('.high-stress-range-item');
                const sid = parseInt(item.dataset.sessionId, 10);
                const idx = parseInt(item.dataset.rangeIndex, 10);
                const val = this.dataset.value;
                const s = savedSessions.find(x => x.id === sid);
                if (s && !s.stressRangeLabels) s.stressRangeLabels = [];
                if (s) {
                    s.stressRangeLabels[idx] = s.stressRangeLabels[idx] || {};
                    s.stressRangeLabels[idx].type = val;
                    saveSessions();
                }
                item.querySelectorAll('.stress-face-btn').forEach(b => b.classList.remove('selected'));
                this.classList.add('selected');
            });
        });
        rangesEl.querySelectorAll('.stress-category-select').forEach(sel => {
            sel.addEventListener('change', function() {
                const item = this.closest('.high-stress-range-item');
                const sid = parseInt(item.dataset.sessionId, 10);
                const idx = parseInt(item.dataset.rangeIndex, 10);
                const s = savedSessions.find(x => x.id === sid);
                if (s && !s.stressRangeLabels) s.stressRangeLabels = [];
                if (s) {
                    s.stressRangeLabels[idx] = s.stressRangeLabels[idx] || {};
                    s.stressRangeLabels[idx].category = this.value;
                    saveSessions();
                }
            });
        });
    }
}

// Close session detail view
function closeSessionDetail() {
    const detailView = document.getElementById('session-detail-view');
    detailView.style.display = 'none';
}

</script>
